{"version":3,"sources":["JSXServeServerTools.ts"],"names":[],"mappings":"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","file":"JSXServeServerTools.js","sourcesContent":["import { IJSXServeHandlerObject } from \"./IJSXServeHandlerObject\";\n\nimport * as http from \"http\";\nimport * as url from \"url\";\n\nexport module JSXServeServerTools {\n    \n    /**\n     * creates a filter function to filter all views that are registered at\n     * the url\n     * @param {string[]} urlPathArray list of url sections (split by /)\n     */\n    export const matchViewToPath = function (urlPathArray: string[]) {\n        return function (handler: IJSXServeHandlerObject) {\n            const handlerHasMatchingPathLengths = urlPathArray.length === handler.path.length;\n\n            // find matching path section -> possibly heavy as long\n            // paths could be filtered, thus in an own function\n            // which is only being invoked when handlerHasMatchingPathLengths\n            // is evaluated as true\n            const findMatchingPathSections = function () {\n                return urlPathArray.filter(function (currentPathSection, index) {\n                    return handler.path[index] === currentPathSection;\n                });\n            };\n\n            return handlerHasMatchingPathLengths && findMatchingPathSections()\n                .length === urlPathArray.length;\n        }\n    };\n\n    /**\n     * check if an object is a Promise\n     * @param val object to check\n     */\n    export const isObjectPromise = function <T>(val: any): val is Promise<T> {\n        return typeof val === \"object\" && !!val.then && typeof val.then === \"function\";\n    }\n\n    /**\n     * create a new http.Server instance routing requests to the correct handlers\n     * @param _handlers list of the handler which should be reachable by requests later\n     */\n    export const createServer = function (_handlers: IJSXServeHandlerObject[]) {\n        return http.createServer(function (request: http.IncomingMessage, response: http.ServerResponse) {\n\n            // request.url can be undefined, thus replace with \"/\" if needed\n            const requestUrl = request.url || \"/\";\n\n            // split the requestUrl by \"/\", but makes sure not to include the initial \"/\"\n            // and not to include the query\n            const requestUrlPathSections = requestUrl.slice(1, (function (index: number) {\n                if (index !== -1) {\n                    return index;\n                }\n\n                return undefined;\n            })(requestUrl.indexOf(\"?\"))).split(\"/\");\n\n\n            // search for a request handler which is hooked to the url of the request\n            // and is featuring the correct HTTP method\n            const requestMatchingHandler: IJSXServeHandlerObject | undefined = _handlers\n                .filter(matchViewToPath(requestUrlPathSections))\n                .filter(function (handler) {\n                    return handler.method === request.method;\n                })[0];\n\n            // we might not have found any handler, which is the case\n            // when the requestMatchingHandler is undefined\n            if (requestMatchingHandler === undefined) {\n                return response.end(JSON.stringify({ error: \"no handler found\" }));\n            }\n\n            // build a handler argument array populated with the arguments from the query\n            const requestMatchingHandlerArguments = ((function (queryStringArguments: any) {\n                if (Object.keys(queryStringArguments).length === requestMatchingHandler.args.length) {\n                    return requestMatchingHandler.args.map(function (argument: string) {\n                        return queryStringArguments[argument];\n                    });\n                }\n            })(url.parse(requestUrl, true).query) || []).filter(function (argument) {\n                return argument !== undefined;\n            });\n\n            // if no arguments are required, the array can be undefined; but if arguments are required\n            // and the argument array is still undefined, not enought argument were prominent in the\n            // request\n            if (requestMatchingHandler.args.length !== requestMatchingHandlerArguments.length) {\n                return response.end(JSON.stringify({ error: \"not enought arguments provided\" }));\n            };\n\n            // catch the returned value of the handler; this can be any value, even a Promise\n            const requestMatchingHandlerResult = requestMatchingHandler.handler.apply(\n                null, requestMatchingHandlerArguments);\n\n            /**\n             * send any string or buffer back to the requesting client, sends an error\n             * if the result is not a string or buffer;\n             * should only be invoked once\n             * @param result object (optimally a string or buffer) to be sent\n             */\n            const sendRequestMatchingHandlerResult = function (result: any) {\n                if (typeof result === \"string\" || Buffer.isBuffer(result)) {\n                    return response.end(result);\n                }\n\n                return response.end(JSON.stringify({ error: \"handler response not supported\" }));\n            }\n\n            // if the result of the handler is a promise, await the result\n            // and then send the result\n            if (isObjectPromise(requestMatchingHandlerResult)) {\n                return requestMatchingHandlerResult\n                    .then(sendRequestMatchingHandlerResult)\n                    .catch(sendRequestMatchingHandlerResult);\n            }\n\n            // the result of the handler was not a promise, respond immediately\n            sendRequestMatchingHandlerResult(requestMatchingHandlerResult);\n        });\n    };\n}"],"sourceRoot":"/home/jakob/Dokumente/Entwicklung/github/jsx-serve/src"}